package sim

import "container/heap"

// Run an event based simulation. The core of the simulation is a for loop that pops the
// next event from an event queue in time order, calls the callback function associated to
// the event and push back in the event queue any events generated by the callback.
// The event queue is implemented as a Priority Queue (Min heap) which returns the event
// with the minimum time (next event chronologically).
// Time in the simulation has not tie with real clock time, that is it is relative among
// the events of the simulation. For example assuming the events queue contains two events
// timestamped time=3 and time=20, the event with time=3 is going to run before the one
// with time=20 - but that does not mean that there are 17 seconds real clock time between
// the two events.
//
// The function receives as parameter
//  - maxTime: how long the simulation runs
//  - q: the event queue which contains the events to seed the simulation
//  - timeOverCallback: a callback to perform operations once maxTime is reached. The
//    callback is useful to stop generating events or in general perform cleanup
func Run(maxTime float64, q *EventsQueue, timeOverCallback OnTimeOver) {
	t := 0.0
	heap.Init(q)

	for q.Len() > 0 {
		item := heap.Pop(q)
		e := item.(*Event)
		t = e.Time

		events := e.CallbackFun(t, e.Payload)
		for _, ev := range events {
			evCopy := ev
			heap.Push(q, &evCopy)
		}

		if t > maxTime {
			timeOverCallback()
		}
	}
}

// OnTimeOver is the callback function called by the simulator when the simulation
// maxTime is reached
type OnTimeOver func()
